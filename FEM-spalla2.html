<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analisi FEM Professionale - Suite V83 Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; background-color: #050505; color: #fff; }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        
        #ui-panel {
            position: absolute; top: 15px; right: 15px; width: 340px;
            background: rgba(15, 15, 20, 0.98); padding: 0; border-radius: 12px;
            border: 1px solid #333; border-top: 4px solid #007acc;
            box-shadow: 0 15px 35px rgba(0,0,0,0.8);
            max-height: 94vh; overflow-y: auto; z-index: 100; backdrop-filter: blur(15px);
        }

        .panel-header { padding: 18px; background: #111; border-bottom: 1px solid #222; }
        .panel-header h2 { margin: 0; font-size: 14px; text-transform: uppercase; letter-spacing: 1.5px; color: #00bfff; }
        .panel-body { padding: 18px; }

        h4 { margin: 12px 0 6px 0; font-size: 10px; color: #666; text-transform: uppercase; border-bottom: 1px solid #222; padding-bottom: 4px; }
        .control-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .label-text { font-size: 11px; color: #aaa; }
        .val { font-family: 'JetBrains Mono', monospace; color: #00bfff; font-weight: bold; font-size: 12px; }

        input[type="range"] { width: 100%; margin: 4px 0 12px 0; -webkit-appearance: none; height: 3px; background: #333; border-radius: 2px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: #007acc; border-radius: 50%; cursor: pointer; border: 2px solid #fff; box-shadow: 0 0 10px rgba(0,122,204,0.5); }
        select { width: 100%; background: #1a1a20; border: 1px solid #444; color: white; padding: 8px; margin-bottom: 12px; border-radius: 6px; font-size: 11px; }

        .results-card { background: #0a0a0a; border-radius: 8px; padding: 12px; border: 1px solid #222; margin-top: 15px; }
        .stat-line { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 11px; }
        .status-badge { 
            width: 100%; padding: 10px; border-radius: 6px; text-align: center; 
            font-weight: bold; font-size: 12px; text-transform: uppercase; margin-top: 8px;
        }
        .safe { background: #0a3d1b; color: #4dff88; border: 1px solid #1a5c2d; }
        .warning { background: #3d330a; color: #ffcc00; border: 1px solid #5c4d1a; }
        .danger { background: #3d0a0a; color: #ff4d4d; border: 1px solid #5c1a1a; }
        
        #crit-panel {
            position: absolute; bottom: 30px; left: 30px; width: 260px;
            background: rgba(10, 10, 15, 0.95); border: 1px solid #444; border-radius: 8px; padding: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); z-index: 50;
        }
        canvas#crit-canvas { width: 100%; height: 160px; background: #000; border-radius: 4px; border: 1px solid #222; }

        #legend {
            position: absolute; bottom: 30px; left: 310px;
            background: rgba(10, 10, 10, 0.9); padding: 15px; border-radius: 8px;
            border: 1px solid #333; z-index: 50;
        }
        .gradient-bar { width: 20px; height: 180px; background: linear-gradient(to top, #30123b, #4686fb, #1ae4b6, #a4fc3b, #f19e0d, #d12e08, #7a0403); border-radius: 3px; border: 1px solid #444; }
        .legend-labels { height: 180px; display: flex; flex-direction: column; justify-content: space-between; font-family: monospace; font-size: 10px; margin-left: 10px; color: #888; }

        #solver-toast {
            position: fixed; bottom: 20px; right: 370px; padding: 12px 20px;
            background: #007acc; color: white; border-radius: 6px; font-size: 12px;
            font-weight: bold; display: none; z-index: 200; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        #loader { position: fixed; top:0; left:0; width:100%; height:100%; background:#050505; display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:1000; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>
</head>
<body>

    <div id="loader">
        <div style="border: 3px solid #222; border-top: 3px solid #00bfff; border-radius: 50%; width: 50px; height: 50px; animation: spin 0.8s linear infinite;"></div>
        <div style="margin-top: 25px; color:#00bfff; font-size: 11px; letter-spacing: 3px; font-weight: bold;">INIZIALIZZAZIONE SOLUTORE FEM...</div>
    </div>

    <div id="solver-toast">CALCOLO FEM IN CORSO...</div>

    <div id="canvas-container"></div>

    <div id="ui-panel">
        <div class="panel-header"><h2>FEM Master Pro V83</h2></div>
        <div class="panel-body">
            
            <h4>Precisione Mesh</h4>
            <div class="control-row"><span class="label-text">Densit&agrave; Mesh (Res)</span><span id="v-mesh-res" class="val">--</span></div>
            <input type="range" id="i-mesh-res" min="1.0" max="4.0" step="0.1" value="1.8">
            <div style="font-size:9px; color:#666; margin-bottom:10px;">Valori bassi = Mesh più fitta (più lento ma più preciso)</div>

            <h4>Geometria e Raccordo</h4>
            <div class="control-row"><span class="label-text">Raggio Curvatura</span><span id="v-fillet" class="val">--</span></div>
            <input type="range" id="i-fillet" min="0" max="40" step="1" value="20">

            <div class="control-row"><span class="label-text">Tipo Profilo</span></div>
            <select id="sel-fillet-type">
                <option value="convex" selected>Convesso (Rinforzato)</option>
                <option value="concave">Concavo (Svasato)</option>
            </select>

            <div class="control-row"><span class="label-text">Transizione (Delta)</span><span id="v-delta" class="val">--</span></div>
            <input type="range" id="i-delta" min="10" max="80" step="2" value="40">

            <h4>Foro Grano</h4>
            <div class="control-row"><span class="label-text">Ø Grano (mm)</span><span id="v-grub" class="val">--</span></div>
            <input type="range" id="i-grub" min="0" max="12" step="0.5" value="6.0">

            <h4>Accoppiamento</h4>
            <div class="control-row"><span class="label-text">Ø Foro Spina (Di)</span><span id="v-di" class="val">--</span></div>
            <input type="range" id="i-di" min="8" max="30" step="1" value="15">

            <div class="control-row"><span class="label-text">Ø Esterno (De)</span><span id="v-de" class="val">--</span></div>
            <input type="range" id="i-de" min="20" max="100" step="1" value="40">

            <div class="control-row"><span class="label-text">Gioco Meccanico (mm)</span><span id="v-clearance" class="val">--</span></div>
            <input type="range" id="i-clearance" min="0" max="1.0" step="0.05" value="0.10">

            <h4>Analisi Carico</h4>
            <div class="control-row"><span class="label-text">Forza Carico (N)</span><span id="v-force" class="val">--</span></div>
            <input type="range" id="i-force" min="0" max="40000" step="100" value="4500">

            <select id="sel-mat">
                <option value="al_pd" selected>Alluminio Pressofuso - 140 MPa</option>
                <option value="al_g">Alluminio T6 - 210 MPa</option>
                <option value="zamak">Zamak 27 (Zinco) - 370 MPa</option>
            </select>

            <h4>Sezione</h4>
            <div class="control-row"><span class="label-text" style="color:#007acc">Slicer Y</span><span id="v-clip" class="val">--</span></div>
            <input type="range" id="i-clip" min="-25" max="150" step="1" value="150">

            <div class="results-card">
                <div class="stat-line"><span>Nodi Mesh</span><span id="r-nodes" class="val">--</span></div>
                <div class="stat-line"><span>Elementi Mesh</span><span id="r-elements" class="val">--</span></div>
                <div class="stat-line"><span>Iterazioni Solver</span><span id="r-iterations" class="val">--</span></div>
                <div class="stat-line"><span>Tempo Calcolo</span><span id="r-time" class="val">--</span></div>
                <div class="stat-line"><span>Stress Von Mises Max</span><span id="r-stress" class="val">-- MPa</span></div>
                <div class="stat-line"><span>Safety Factor</span><span id="r-sf" class="val">--</span></div>
                <div id="r-status-box" class="status-badge">---</div>
            </div>
            
            <div class="control-row" style="margin-top:10px;">
                <span class="label-text">Mostra Mesh (Wireframe)</span>
                <input type="checkbox" id="chk-wireframe">
            </div>
        </div>
    </div>

    <div id="crit-panel">
        <canvas id="crit-canvas"></canvas>
    </div>

    <div id="legend">
        <div class="gradient-bar"></div>
        <div class="legend-labels">
            <div id="l-max">MAX</div>
            <div id="l-mid">MID</div>
            <div>0</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- TRUE FEM SOLVER WITH ADAPTIVE MESH ---
        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const safeSqrt = (v) => v > 1e-9 ? Math.sqrt(v) : 0;

        const W_BASE = 30, H_BASE = 50, L_TOTAL = 100, Y_LOAD = 100;
        const materials = {
            'al_pd': { E: 71000, Yield: 140, nu: 0.33 },
            'al_g':  { E: 74000, Yield: 210, nu: 0.33 },
            'zamak': { E: 85000, Yield: 370, nu: 0.27 }
        };

        // ============================================================
        // SPARSE MATRIX CLASS (CSR-like format using Map)
        // ============================================================
        class SparseMatrix {
            constructor(size) {
                this.size = size;
                this.data = new Map(); // key: "i,j" -> value
            }
            
            set(i, j, value) {
                if (Math.abs(value) > 1e-15) {
                    this.data.set(`${i},${j}`, value);
                }
            }
            
            add(i, j, value) {
                const key = `${i},${j}`;
                const current = this.data.get(key) || 0;
                this.set(i, j, current + value);
            }
            
            get(i, j) {
                return this.data.get(`${i},${j}`) || 0;
            }
            
            // Sparse matrix-vector multiplication: result = A * x
            multiply(x) {
                const result = new Float64Array(this.size);
                for (const [key, value] of this.data.entries()) {
                    const [i, j] = key.split(',').map(Number);
                    result[i] += value * x[j];
                }
                return result;
            }
            
            // Get diagonal for preconditioning
            getDiagonal() {
                const diag = new Float64Array(this.size);
                for (let i = 0; i < this.size; i++) {
                    diag[i] = this.get(i, i) || 1.0;
                }
                return diag;
            }
        }

        // ============================================================
        // HEX8 FINITE ELEMENT (8-node brick element)
        // ============================================================
        class Hex8Element {
            constructor(nodeCoords, E, nu) {
                // nodeCoords: array of 8 nodes, each {x, y, z}
                this.nodes = nodeCoords;
                this.E = E;
                this.nu = nu;
                this.D = this.buildConstitutiveMatrix();
            }
            
            // Build 6x6 constitutive matrix for 3D elasticity
            buildConstitutiveMatrix() {
                const E = this.E, nu = this.nu;
                const lambda = E * nu / ((1 + nu) * (1 - 2 * nu));
                const mu = E / (2 * (1 + nu));
                const D = new Array(6).fill(0).map(() => new Array(6).fill(0));
                
                // Voigt notation: [σxx, σyy, σzz, τxy, τyz, τzx]
                D[0][0] = D[1][1] = D[2][2] = lambda + 2*mu;
                D[0][1] = D[0][2] = D[1][0] = D[1][2] = D[2][0] = D[2][1] = lambda;
                D[3][3] = D[4][4] = D[5][5] = mu;
                
                return D;
            }
            
            // Shape functions in natural coordinates (ξ, η, ζ) ∈ [-1,1]
            shapeFunction(xi, eta, zeta) {
                const N = new Float64Array(8);
                const coords = [
                    [-1,-1,-1], [1,-1,-1], [1,1,-1], [-1,1,-1],
                    [-1,-1,1], [1,-1,1], [1,1,1], [-1,1,1]
                ];
                for (let i = 0; i < 8; i++) {
                    const [xi_i, eta_i, zeta_i] = coords[i];
                    N[i] = 0.125 * (1 + xi_i*xi) * (1 + eta_i*eta) * (1 + zeta_i*zeta);
                }
                return N;
            }
            
            // Derivatives of shape functions w.r.t. natural coords
            shapeFunctionDerivatives(xi, eta, zeta) {
                const dN = Array(8).fill(0).map(() => [0, 0, 0]);
                const coords = [
                    [-1,-1,-1], [1,-1,-1], [1,1,-1], [-1,1,-1],
                    [-1,-1,1], [1,-1,1], [1,1,1], [-1,1,1]
                ];
                for (let i = 0; i < 8; i++) {
                    const [xi_i, eta_i, zeta_i] = coords[i];
                    dN[i][0] = 0.125 * xi_i * (1 + eta_i*eta) * (1 + zeta_i*zeta);   // dN/dξ
                    dN[i][1] = 0.125 * (1 + xi_i*xi) * eta_i * (1 + zeta_i*zeta);    // dN/dη
                    dN[i][2] = 0.125 * (1 + xi_i*xi) * (1 + eta_i*eta) * zeta_i;     // dN/dζ
                }
                return dN;
            }
            
            // Jacobian matrix: J = ∂(x,y,z)/∂(ξ,η,ζ)
            jacobian(xi, eta, zeta) {
                const dN = this.shapeFunctionDerivatives(xi, eta, zeta);
                const J = [[0,0,0], [0,0,0], [0,0,0]];
                
                for (let i = 0; i < 8; i++) {
                    J[0][0] += dN[i][0] * this.nodes[i].x;  // ∂x/∂ξ
                    J[0][1] += dN[i][0] * this.nodes[i].y;  // ∂y/∂ξ
                    J[0][2] += dN[i][0] * this.nodes[i].z;  // ∂z/∂ξ
                    J[1][0] += dN[i][1] * this.nodes[i].x;  // ∂x/∂η
                    J[1][1] += dN[i][1] * this.nodes[i].y;  // ∂y/∂η
                    J[1][2] += dN[i][1] * this.nodes[i].z;  // ∂z/∂η
                    J[2][0] += dN[i][2] * this.nodes[i].x;  // ∂x/∂ζ
                    J[2][1] += dN[i][2] * this.nodes[i].y;  // ∂y/∂ζ
                    J[2][2] += dN[i][2] * this.nodes[i].z;  // ∂z/∂ζ
                }
                return J;
            }
            
            // Determinant of 3x3 matrix
            det3x3(M) {
                return M[0][0]*(M[1][1]*M[2][2] - M[1][2]*M[2][1]) -
                       M[0][1]*(M[1][0]*M[2][2] - M[1][2]*M[2][0]) +
                       M[0][2]*(M[1][0]*M[2][1] - M[1][1]*M[2][0]);
            }
            
            // Inverse of 3x3 matrix
            inv3x3(M) {
                const det = this.det3x3(M);
                if (Math.abs(det) < 1e-12) return null;
                
                const inv = [[0,0,0], [0,0,0], [0,0,0]];
                inv[0][0] = (M[1][1]*M[2][2] - M[1][2]*M[2][1]) / det;
                inv[0][1] = (M[0][2]*M[2][1] - M[0][1]*M[2][2]) / det;
                inv[0][2] = (M[0][1]*M[1][2] - M[0][2]*M[1][1]) / det;
                inv[1][0] = (M[1][2]*M[2][0] - M[1][0]*M[2][2]) / det;
                inv[1][1] = (M[0][0]*M[2][2] - M[0][2]*M[2][0]) / det;
                inv[1][2] = (M[0][2]*M[1][0] - M[0][0]*M[1][2]) / det;
                inv[2][0] = (M[1][0]*M[2][1] - M[1][1]*M[2][0]) / det;
                inv[2][1] = (M[0][1]*M[2][0] - M[0][0]*M[2][1]) / det;
                inv[2][2] = (M[0][0]*M[1][1] - M[0][1]*M[1][0]) / det;
                return inv;
            }
            
            // B matrix (strain-displacement): 6x24
            buildBMatrix(xi, eta, zeta) {
                const dN_natural = this.shapeFunctionDerivatives(xi, eta, zeta);
                const J = this.jacobian(xi, eta, zeta);
                const invJ = this.inv3x3(J);
                if (!invJ) return null;
                
                // Transform derivatives to physical coordinates
                const dN_phys = Array(8).fill(0).map(() => [0, 0, 0]);
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 3; j++) {
                        dN_phys[i][j] = invJ[j][0]*dN_natural[i][0] + 
                                       invJ[j][1]*dN_natural[i][1] + 
                                       invJ[j][2]*dN_natural[i][2];
                    }
                }
                
                // Build B matrix (6 x 24)
                const B = Array(6).fill(0).map(() => Array(24).fill(0));
                for (let i = 0; i < 8; i++) {
                    const col = i * 3;
                    B[0][col]   = dN_phys[i][0];  // εxx
                    B[1][col+1] = dN_phys[i][1];  // εyy
                    B[2][col+2] = dN_phys[i][2];  // εzz
                    B[3][col]   = dN_phys[i][1];  B[3][col+1] = dN_phys[i][0];  // γxy
                    B[4][col+1] = dN_phys[i][2];  B[4][col+2] = dN_phys[i][1];  // γyz
                    B[5][col]   = dN_phys[i][2];  B[5][col+2] = dN_phys[i][0];  // γzx
                }
                
                return B;
            }
            
            // Element stiffness matrix Ke (24x24) with 2x2x2 Gauss integration
            computeStiffnessMatrix() {
                const Ke = Array(24).fill(0).map(() => new Float64Array(24));
                const gp = 1/Math.sqrt(3); // Gauss points at ±1/√3
                const gaussPoints = [
                    [-gp,-gp,-gp], [gp,-gp,-gp], [gp,gp,-gp], [-gp,gp,-gp],
                    [-gp,-gp,gp], [gp,-gp,gp], [gp,gp,gp], [-gp,gp,gp]
                ];
                
                for (const [xi, eta, zeta] of gaussPoints) {
                    const B = this.buildBMatrix(xi, eta, zeta);
                    if (!B) continue;
                    
                    const J = this.jacobian(xi, eta, zeta);
                    const detJ = this.det3x3(J);
                    if (detJ <= 0) continue;
                    
                    // Ke += B^T * D * B * detJ (weight=1 for all Gauss points)
                    for (let i = 0; i < 24; i++) {
                        for (let j = 0; j < 24; j++) {
                            let sum = 0;
                            for (let k = 0; k < 6; k++) {
                                for (let l = 0; l < 6; l++) {
                                    sum += B[k][i] * this.D[k][l] * B[l][j];
                                }
                            }
                            Ke[i][j] += sum * detJ;
                        }
                    }
                }
                
                return Ke;
            }
            
            // Compute stress at element center
            computeStress(U_element) {
                // U_element: 24-component displacement vector for this element
                const B = this.buildBMatrix(0, 0, 0); // Evaluate at center
                if (!B) return null;
                
                // Strain: ε = B * U
                const strain = new Float64Array(6);
                for (let i = 0; i < 6; i++) {
                    for (let j = 0; j < 24; j++) {
                        strain[i] += B[i][j] * U_element[j];
                    }
                }
                
                // Stress: σ = D * ε
                const stress = new Float64Array(6);
                for (let i = 0; i < 6; i++) {
                    for (let j = 0; j < 6; j++) {
                        stress[i] += this.D[i][j] * strain[j];
                    }
                }
                
                return stress;
            }
        }

        // ============================================================
        // FEM SOLVER - Preconditioned Conjugate Gradient
        // ============================================================
        class FEMSolver {
            constructor(tolerance = 1e-6, maxIterations = 2000) {
                this.tolerance = tolerance;
                this.maxIterations = maxIterations;
                this.iterations = 0;
            }
            
            // Solve K * U = F using PCG with Jacobi preconditioner
            solve(K, F) {
                const n = K.size;
                const U = new Float64Array(n);
                
                // Jacobi preconditioner: M = diag(K)
                const M_inv = K.getDiagonal();
                for (let i = 0; i < n; i++) {
                    M_inv[i] = M_inv[i] > 1e-12 ? 1.0 / M_inv[i] : 0;
                }
                
                // Initial residual: r = F - K*U (U=0, so r=F)
                let r = new Float64Array(F);
                
                // Preconditioned residual: z = M^-1 * r
                let z = new Float64Array(n);
                for (let i = 0; i < n; i++) z[i] = M_inv[i] * r[i];
                
                // Initial search direction
                let p = new Float64Array(z);
                let rzOld = this.dot(r, z);
                
                this.iterations = 0;
                for (let iter = 0; iter < this.maxIterations; iter++) {
                    this.iterations = iter + 1;
                    
                    // Ap = K * p
                    const Ap = K.multiply(p);
                    
                    // alpha = (r^T * z) / (p^T * Ap)
                    const pAp = this.dot(p, Ap);
                    if (Math.abs(pAp) < 1e-20) break;
                    const alpha = rzOld / pAp;
                    
                    // Update solution: U = U + alpha * p
                    for (let i = 0; i < n; i++) U[i] += alpha * p[i];
                    
                    // Update residual: r = r - alpha * Ap
                    for (let i = 0; i < n; i++) r[i] -= alpha * Ap[i];
                    
                    // Check convergence
                    const residualNorm = Math.sqrt(this.dot(r, r));
                    if (residualNorm < this.tolerance) break;
                    
                    // Update preconditioned residual: z = M^-1 * r
                    for (let i = 0; i < n; i++) z[i] = M_inv[i] * r[i];
                    
                    // beta = (r_new^T * z_new) / (r_old^T * z_old)
                    const rzNew = this.dot(r, z);
                    const beta = rzNew / rzOld;
                    rzOld = rzNew;
                    
                    // Update search direction: p = z + beta * p
                    for (let i = 0; i < n; i++) p[i] = z[i] + beta * p[i];
                }
                
                return U;
            }
            
            dot(a, b) {
                let sum = 0;
                for (let i = 0; i < a.length; i++) sum += a[i] * b[i];
                return sum;
            }
        }

        // ============================================================
        // ADAPTIVE MESH GENERATOR
        // ============================================================
        class AdaptiveMeshGenerator {
            constructor(state, W_BASE, H_BASE, L_TOTAL) {
                this.state = state;
                this.W_BASE = W_BASE;
                this.H_BASE = H_BASE;
                this.L_TOTAL = L_TOTAL;
            }
            
            // Local sizing function - smaller values = finer mesh
            getSizingFactor(x, y, z) {
                const rIn = this.state.Di / 2;
                const rOut = this.state.De / 2;
                const rGrub = this.state.grubDi / 2;
                const pivotZ = this.H_BASE / 2;
                
                let factor = 1.0;
                
                // Refine near internal hole (Di)
                const distHole = Math.sqrt(x*x + y*y);
                if (distHole < rIn * 1.5) {
                    factor = Math.min(factor, 0.4);
                }
                
                // Refine near grub screw hole
                if (this.state.grubDi > 0.1) {
                    const distGrub = Math.sqrt(y*y + (z - pivotZ)**2);
                    if (distGrub < rGrub * 3) {
                        factor = Math.min(factor, 0.4);
                    }
                }
                
                // Refine in transition zone
                if (y >= 0 && y <= this.state.delta * 1.2) {
                    factor = Math.min(factor, 0.5);
                }
                
                // Refine near load application
                if (y > this.L_TOTAL * 0.85) {
                    factor = Math.min(factor, 0.5);
                }
                
                // Refine in fillet regions
                if (this.state.fillet > 0 && y >= 0 && y <= this.state.delta) {
                    const hw = this.getProfileHalfWidth(y);
                    if (Math.abs(Math.abs(x) - hw) < this.state.fillet * 0.5) {
                        factor = Math.min(factor, 0.3);
                    }
                }
                
                return factor;
            }
            
            getProfileHalfWidth(y) {
                const hw_block = this.W_BASE / 2, hw_hub = this.state.De / 2;
                if (y >= this.state.delta) return hw_block; 
                if (y <= 0) {
                    const dy = Math.abs(y);
                    return dy > hw_hub ? 0.05 : safeSqrt(hw_hub**2 - dy**2);
                }
                const t = clamp(y / this.state.delta, 0, 1), s = (3 * t**2 - 2 * t**3); 
                const neckEffect = this.state.fillet * Math.sin(t * Math.PI); 
                let currentHW;
                if (this.state.filletType === 'convex') currentHW = hw_hub + (hw_block - hw_hub) * s + neckEffect;
                else currentHW = hw_hub + (hw_block - hw_hub) * s - neckEffect;
                return Math.max(1, currentHW);
            }
            
            // Generate adaptive mesh
            generate() {
                const nodes = [];
                const elements = [];
                const nodeMap = new Map();
                const rIn = this.state.Di / 2;
                const rGrub = this.state.grubDi / 2;
                const rOut = this.state.De / 2;
                const pivotZ = this.H_BASE / 2;
                
                const getNode = (x, y, z) => {
                    const key = `${x.toFixed(3)},${y.toFixed(3)},${z.toFixed(3)}`;
                    if (nodeMap.has(key)) return nodeMap.get(key);
                    const node = { x, y, z, vm: 0, count: 0 };
                    nodes.push(node);
                    nodeMap.set(key, nodes.length - 1);
                    return nodes.length - 1;
                };
                
                // Sample mesh at midpoint to determine local size
                const baseStep = this.state.meshRes;
                const xSegments = 20;
                
                for (let y = -rOut; y < this.L_TOTAL; y += baseStep * 0.8) {
                    const hw0 = this.getProfileHalfWidth(y);
                    const hw1 = this.getProfileHalfWidth(y + baseStep);
                    
                    // Adaptive sizing in y direction
                    const midY = y + baseStep * 0.5;
                    const sizeFactor = this.getSizingFactor(0, midY, pivotZ);
                    const stepY = baseStep * sizeFactor;
                    
                    for (let x_idx = -xSegments; x_idx < xSegments; x_idx++) {
                        const tx0 = x_idx / xSegments, tx1 = (x_idx + 1) / xSegments;
                        const x0a = tx0 * hw0, x0b = tx1 * hw0;
                        const x1a = tx0 * hw1, x1b = tx1 * hw1;
                        const midX = (x0a + x0b) / 2;
                        
                        // Adaptive sizing in z direction
                        const zSizeFactor = this.getSizingFactor(midX, midY, pivotZ);
                        const stepZ = baseStep * zSizeFactor;
                        
                        for (let z = 0; z < this.H_BASE; z += stepZ) {
                            const distPin = safeSqrt(midX**2 + y**2);
                            const distGrub = safeSqrt(y**2 + (z - pivotZ)**2);
                            
                            // Skip elements inside holes
                            if (distPin < rIn) continue;
                            if (this.state.grubDi > 0.1 && distGrub < rGrub && midX > rIn * 0.9) continue;
                            
                            // Create element with controlled aspect ratio
                            const actualStepZ = Math.min(stepZ, this.H_BASE - z);
                            const actualStepY = Math.min(stepY, this.L_TOTAL - y);
                            
                            try {
                                const n = [
                                    getNode(x0a, y, z), getNode(x0b, y, z),
                                    getNode(x1b, y+actualStepY, z), getNode(x1a, y+actualStepY, z),
                                    getNode(x0a, y, z+actualStepZ), getNode(x0b, y, z+actualStepZ),
                                    getNode(x1b, y+actualStepY, z+actualStepZ), getNode(x1a, y+actualStepY, z+actualStepZ)
                                ];
                                elements.push({ nodes: n });
                            } catch(e) {
                                // Skip malformed elements
                            }
                        }
                    }
                }
                
                return { nodes, elements };
            }
        }

        // ============================================================
        // STRESS CALCULATOR
        // ============================================================
        class StressCalculator {
            static computeVonMises(stress) {
                // stress: [σxx, σyy, σzz, τxy, τyz, τzx]
                const [sx, sy, sz, txy, tyz, tzx] = stress;
                const vm = Math.sqrt(0.5 * (
                    (sx-sy)**2 + (sy-sz)**2 + (sz-sx)**2 + 
                    6 * (txy**2 + tyz**2 + tzx**2)
                ));
                return vm;
            }
            
            static smoothNodalStresses(nodes, elements, U, E, nu) {
                // Reset nodal stresses
                nodes.forEach(n => { n.vm = 0; n.count = 0; });
                
                // Accumulate element stresses to nodes
                elements.forEach(el => {
                    const nodeCoords = el.nodes.map(idx => nodes[idx]);
                    const element = new Hex8Element(nodeCoords, E, nu);
                    
                    // Get element displacement vector
                    const U_el = new Float64Array(24);
                    for (let i = 0; i < 8; i++) {
                        const nodeIdx = el.nodes[i];
                        U_el[i*3]   = U[nodeIdx*3]   || 0;
                        U_el[i*3+1] = U[nodeIdx*3+1] || 0;
                        U_el[i*3+2] = U[nodeIdx*3+2] || 0;
                    }
                    
                    const stress = element.computeStress(U_el);
                    if (stress) {
                        const vm = StressCalculator.computeVonMises(stress);
                        
                        // Distribute to nodes
                        el.nodes.forEach(idx => {
                            nodes[idx].vm += vm;
                            nodes[idx].count += 1;
                        });
                    }
                });
                
                // Average
                nodes.forEach(n => {
                    if (n.count > 0) n.vm /= n.count;
                });
            }
        }

        const state = {
            meshRes: 2.0, delta: 40, De: 40, Di: 15, grubDi: 6.0, clearance: 0.1, force: 4500, fillet: 20, filletType: 'convex', matId: 'al_pd', clipY: 150, showWireframe: false
        };

        let scene, camera, renderer, controls, clipPlane, mainMesh, wireMesh, pinMesh, grubMesh, forceArrow;
        let nodes = [], elements = [], dom = {}, globalU = null;
        let solverStats = { numNodes: 0, numElements: 0, iterations: 0, solveTime: 0 };

        function init() {
            const container = document.getElementById('canvas-container');
            const getEl = (id) => document.getElementById(id);
            
            dom = {
                meshRes: getEl('i-mesh-res'), vMeshRes: getEl('v-mesh-res'),
                fillet: getEl('i-fillet'), vFillet: getEl('v-fillet'),
                grub: getEl('i-grub'), vGrub: getEl('v-grub'),
                de: getEl('i-de'), vDe: getEl('v-de'),
                di: getEl('i-di'), vDi: getEl('v-di'),
                delta: getEl('i-delta'), vDelta: getEl('v-delta'),
                filletType: getEl('sel-fillet-type'),
                force: getEl('i-force'), vForce: getEl('v-force'),
                clip: getEl('i-clip'), vClip: getEl('v-clip'),
                mat: getEl('sel-mat'),
                wireframe: getEl('chk-wireframe'),
                rNodes: getEl('r-nodes'), rElements: getEl('r-elements'),
                rIterations: getEl('r-iterations'), rTime: getEl('r-time'),
                rStress: getEl('r-stress'), rSf: getEl('r-sf'), rStatus: getEl('r-status-box'),
                lMax: getEl('l-max'), lMid: getEl('l-mid'),
                critCanvas: getEl('crit-canvas'),
                toast: getEl('solver-toast')
            };

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0c);
            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.set(200, 180, 200);
            camera.up.set(0, 0, 1);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.localClippingEnabled = true;
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 40, 25);
            controls.enableDamping = true;

            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.position.set(100, 100, 150);
            scene.add(sun);

            clipPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), state.clipY);

            document.querySelectorAll('input, select').forEach(el => {
                el.addEventListener('input', handleUpdate);
            });

            rebuildFEM();
            animate();
            setTimeout(() => { document.getElementById('loader').style.display = 'none'; }, 800);
        }

        function handleUpdate() {
            if (!dom.delta || !dom.meshRes || !dom.clip || !dom.di) return;

            state.meshRes = parseFloat(dom.meshRes.value);
            state.fillet = parseFloat(dom.fillet.value);
            state.De = parseFloat(dom.de.value);
            state.Di = parseFloat(dom.di.value);
            state.delta = parseFloat(dom.delta.value);
            state.grubDi = parseFloat(dom.grub.value);
            state.force = parseFloat(dom.force.value);
            state.clipY = parseFloat(dom.clip.value);
            state.filletType = dom.filletType.value;
            state.matId = dom.mat.value;
            state.showWireframe = dom.wireframe.checked;

            dom.vMeshRes.innerText = state.meshRes.toFixed(1) + " mm";
            dom.vFillet.innerText = state.fillet + " mm";
            dom.vDe.innerText = state.De + " mm";
            dom.vDi.innerText = state.Di + " mm";
            dom.vDelta.innerText = state.delta + " mm";
            dom.vGrub.innerText = state.grubDi.toFixed(1) + " mm";
            dom.vForce.innerText = state.force + " N";
            dom.vClip.innerText = state.clipY > 140 ? "OFF" : state.clipY + " mm";
            clipPlane.constant = state.clipY;

            rebuildFEM();
        }

        function getProfileHalfWidth(y) {
            const hw_block = W_BASE / 2, hw_hub = state.De / 2;
            if (y >= state.delta) return hw_block; 
            if (y <= 0) {
                const dy = Math.abs(y);
                return dy > hw_hub ? 0.05 : safeSqrt(hw_hub**2 - dy**2);
            }
            const t = clamp(y / state.delta, 0, 1), s = (3 * t**2 - 2 * t**3); 
            const neckEffect = state.fillet * Math.sin(t * Math.PI); 
            let currentHW;
            if (state.filletType === 'convex') currentHW = hw_hub + (hw_block - hw_hub) * s + neckEffect;
            else currentHW = hw_hub + (hw_block - hw_hub) * s - neckEffect;
            return Math.max(1, currentHW);
        }

        function rebuildFEM() {
            dom.toast.style.display = 'block';
            dom.toast.innerText = 'GENERAZIONE MESH ADATTIVA...';
            const startTime = performance.now();
            
            if (mainMesh) { scene.remove(mainMesh); mainMesh.geometry.dispose(); }
            if (wireMesh) { scene.remove(wireMesh); wireMesh.geometry.dispose(); }
            
            // Generate adaptive mesh
            const meshGen = new AdaptiveMeshGenerator(state, W_BASE, H_BASE, L_TOTAL);
            const mesh = meshGen.generate();
            nodes = mesh.nodes;
            elements = mesh.elements;
            
            solverStats.numNodes = nodes.length;
            solverStats.numElements = elements.length;
            
            const mat = materials[state.matId];
            const ndof = nodes.length * 3;
            
            dom.toast.innerText = `ASSEMBLAGGIO MATRICE GLOBALE (${elements.length} elementi)...`;
            
            // Assemble global stiffness matrix
            const K = new SparseMatrix(ndof);
            
            elements.forEach((el, idx) => {
                if (idx % 200 === 0) {
                    dom.toast.innerText = `ASSEMBLAGGIO ${Math.floor(100*idx/elements.length)}%...`;
                }
                
                const nodeCoords = el.nodes.map(nodeIdx => nodes[nodeIdx]);
                const element = new Hex8Element(nodeCoords, mat.E, mat.nu);
                const Ke = element.computeStiffnessMatrix();
                
                // Add to global matrix
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const ni = el.nodes[i];
                        const nj = el.nodes[j];
                        for (let di = 0; di < 3; di++) {
                            for (let dj = 0; dj < 3; dj++) {
                                K.add(ni*3+di, nj*3+dj, Ke[i*3+di][j*3+dj]);
                            }
                        }
                    }
                }
            });
            
            dom.toast.innerText = 'APPLICAZIONE CONDIZIONI AL CONTORNO...';
            
            // Apply boundary conditions
            const F = new Float64Array(ndof);
            const rOut = state.De / 2;
            
            // Constraints: fix nodes at y ≈ -rOut (bottom of hub)
            const penalty = 1e30;
            nodes.forEach((node, idx) => {
                if (node.y < -rOut * 0.9) {
                    K.set(idx*3, idx*3, penalty);
                    K.set(idx*3+1, idx*3+1, penalty);
                    K.set(idx*3+2, idx*3+2, penalty);
                    F[idx*3] = 0;
                    F[idx*3+1] = 0;
                    F[idx*3+2] = 0;
                }
            });
            
            // Apply load at top nodes
            let loadNodeCount = 0;
            nodes.forEach((node, idx) => {
                if (node.y > Y_LOAD * 0.95) {
                    loadNodeCount++;
                }
            });
            
            if (loadNodeCount > 0) {
                const forcePerNode = -state.force / loadNodeCount; // Negative Y direction
                nodes.forEach((node, idx) => {
                    if (node.y > Y_LOAD * 0.95) {
                        F[idx*3+1] += forcePerNode;
                    }
                });
            }
            
            dom.toast.innerText = 'RISOLUZIONE SISTEMA PCG...';
            
            // Solve K*U = F
            const solver = new FEMSolver(1e-6, 2000);
            globalU = solver.solve(K, F);
            solverStats.iterations = solver.iterations;
            
            dom.toast.innerText = 'CALCOLO STRESS...';
            
            // Compute stresses
            StressCalculator.smoothNodalStresses(nodes, elements, globalU, mat.E, mat.nu);
            
            solverStats.solveTime = performance.now() - startTime;
            
            // Visualization
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const colorObj = new THREE.Color();
            
            elements.forEach(el => {
                const ns = el.nodes.map(id => nodes[id]);
                const avgVM = ns.reduce((acc, n) => acc + n.vm, 0) / 8;
                const t = clamp(avgVM / mat.Yield, 0, 1.2);
                colorObj.setHSL(0.66 * (1 - Math.min(t, 1)), 1, 0.5);
                if (avgVM > mat.Yield) colorObj.setRGB(1, 1, 1);

                const faces = [[0,1,2,3], [4,5,6,7], [0,1,5,4], [1,2,6,5], [2,3,7,6], [3,0,4,7]];
                faces.forEach(f => {
                    const p1 = ns[f[0]], p2 = ns[f[1]], p3 = ns[f[2]], p4 = ns[f[3]];
                    positions.push(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
                    positions.push(p1.x, p1.y, p1.z, p3.x, p3.y, p3.z, p4.x, p4.y, p4.z);
                    for(let i=0; i<6; i++) colors.push(colorObj.r, colorObj.g, colorObj.b);
                });
            });

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();

            mainMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ 
                vertexColors: true, side: THREE.DoubleSide, clippingPlanes: [clipPlane], roughness: 0.5, metalness: 0.2
            }));
            scene.add(mainMesh);

            if (state.showWireframe) {
                wireMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true, opacity: 0.15 }));
                scene.add(wireMesh);
            }

            // Update UI
            const maxVMGlobal = nodes.length > 0 ? Math.max(...nodes.map(n => n.vm)) : 0;
            dom.rNodes.innerText = solverStats.numNodes;
            dom.rElements.innerText = solverStats.numElements;
            dom.rIterations.innerText = solverStats.iterations;
            dom.rTime.innerText = (solverStats.solveTime / 1000).toFixed(2) + ' s';
            dom.rStress.innerText = maxVMGlobal.toFixed(1) + " MPa";
            const sf = mat.Yield / (maxVMGlobal + 0.01);
            dom.rSf.innerText = sf.toFixed(2);
            dom.rStatus.className = "status-badge " + (sf < 1.0 ? "danger" : sf < 1.3 ? "warning" : "safe");
            dom.rStatus.innerText = sf < 1.0 ? "CEDIMENTO" : sf < 1.3 ? "CRITICO" : "SICURO";
            dom.lMax.innerText = mat.Yield; dom.lMid.innerText = (mat.Yield/2).toFixed(0);

            updateAccessories();
            drawSection();
            setTimeout(() => { dom.toast.style.display = 'none'; }, 400);
        }

        function drawSection() {
            const canvas = dom.critCanvas, ctx = canvas.getContext('2d');
            const w = canvas.width = 240, h = canvas.height = 160;
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, w, h);
            
            const ySlice = state.clipY < 140 ? state.clipY : 0;
            const rOut = state.De/2, rIn = state.Di/2, rG = state.grubDi/2, mat = materials[state.matId];
            const scale = 2.4, cx = w/2, cz = h/2, pZ = H_BASE/2;

            // Draw mesh nodes in the slice
            nodes.forEach(node => {
                if (Math.abs(node.y - ySlice) < state.meshRes * 0.8) {
                    const vm = node.vm || 0;
                    const t = clamp(vm / mat.Yield, 0, 1);
                    ctx.fillStyle = `#${new THREE.Color().setHSL(0.66*(1-t), 1, 0.5).getHexString()}`;
                    ctx.fillRect(cx + node.x*scale, h - node.z*scale, 3, 3);
                }
            });
        }

        function updateAccessories() {
            if (pinMesh) scene.remove(pinMesh);
            pinMesh = new THREE.Mesh(new THREE.CylinderGeometry(state.Di/2-0.1, state.Di/2-0.1, 85, 32).rotateX(Math.PI/2), new THREE.MeshStandardMaterial({color: 0x666666, metalness: 0.8}));
            pinMesh.position.set(0,0,H_BASE/2); scene.add(pinMesh);
            if (grubMesh) scene.remove(grubMesh);
            if (state.grubDi > 0.1) {
                grubMesh = new THREE.Mesh(new THREE.CylinderGeometry(state.grubDi/2-0.1, state.grubDi/2-0.1, 20, 16).rotateZ(Math.PI/2), new THREE.MeshStandardMaterial({color: 0x333333, metalness: 0.5}));
                grubMesh.position.set(state.De/2 - 2, 0, H_BASE/2); scene.add(grubMesh);
            }
            if (forceArrow) scene.remove(forceArrow);
            const dir = new THREE.Vector3(0, -1, 0).normalize();
            forceArrow = new THREE.ArrowHelper(dir, new THREE.Vector3(0, Y_LOAD, H_BASE/2), 35, 0x00ff00); 
            scene.add(forceArrow);
        }

        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
        init();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>